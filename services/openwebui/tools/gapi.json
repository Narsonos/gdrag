{"id":"google_drive","user_id":"4b6f4ccb-a842-4ea7-8f42-8ad7f0c90092","name":"Google Drive","content":"\"\"\"\ntitle: Simple GoogleDrive\nauthor: Narsonos\ndescription: A simple Google Drive integration that allows LLMs access files stored at google drive dynamically.\nversion: 0.0.1\nlicense: None\nrequirements: google-api-python-client, google-auth, google-auth-oauthlib, pandas, pydantic, PyMuPDF, pymupdf4llm, openpyxl, tabulate\n\"\"\"\n\nfrom googleapiclient.discovery import build\nfrom google.oauth2.credentials import Credentials\nfrom google.oauth2 import service_account\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\nfrom googleapiclient.http import MediaIoBaseDownload\nimport os, io, pandas\nfrom typing import Callable, Any\nfrom pydantic import BaseModel, Field\nimport pymupdf4llm  # type: ignore\nimport pymupdf  # type: ignore\nimport json\nimport unittest\n\nEXPORT_MIME = {\n    \"application/vnd.google-apps.document\": \"application/pdf\",\n    \"application/vnd.google-apps.spreadsheet\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n}\n\nEXPORT_EXT_MAP = {\n    \"application/pdf\": \".pdf\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": \".xlsx\",\n}\n\nSERVICE_ACCOUNT = True\n\n\nclass GAPIClientWrapper:\n\n    def __init__(\n        self,\n        service_key,\n        folder_id,\n        scopes=[\"https://www.googleapis.com/auth/drive.readonly\"],\n    ):\n        self.service_key = service_key\n        self.scopes = scopes\n        self.folder_id = folder_id\n\n    async def auth(self):\n        creds = None\n        if SERVICE_ACCOUNT:\n            creds = service_account.Credentials.from_service_account_info(\n                self.service_key, scopes=self.scopes\n            )\n            return creds\n        if os.path.exists(\"token.json\"):\n            creds = Credentials.from_authorized_user_file(\"token.json\")\n\n        if not creds:\n            if creds and creds.expired and creds.refresh_token:\n                creds.refresh(Request())\n            else:\n                flow = InstalledAppFlow.from_client_secrets_file(\n                    \"credentials.json\", scopes=self.scopes\n                )\n                creds = flow.run_local_server(port=3000)\n            with open(\"token.json\", \"w\") as token:\n                token.write(creds.to_json())\n        return creds\n\n    async def list(self, page_size=10, pages=None, q=None):\n        page_token = None\n        rs = []\n        read_pages = 0\n        while True:\n            if pages is None or (not pages is None and read_pages < pages):\n                with build(\"drive\", \"v3\", credentials=await self.auth()) as service:\n                    results = (\n                        service.files()\n                        .list(\n                            q=(\n                                f\"'{self.folder_id}' in parents and ({q})\"\n                                if q\n                                else f\"'{self.folder_id}' in parents\"\n                            ),\n                            pageSize=page_size,\n                            fields=\"nextPageToken, files(id, name, mimeType, description)\",\n                            pageToken=page_token,\n                        )\n                        .execute()\n                    )\n                    rs.extend(results.get(\"files\", []))\n                    page_token = results.get(\"nextPageToken\")\n                read_pages += 1\n            else:\n                break\n            if not page_token:\n                break\n        return rs\n\n    async def getById(self, file_id):\n        with build(\"drive\", \"v3\", credentials=await self.auth()) as service:\n            file = (\n                service.files()\n                .get(fileId=file_id, fields=\"id, name, mimeType\")\n                .execute()\n            )\n            filename = file[\"name\"]\n            mime_type = file[\"mimeType\"]\n\n            if mime_type in EXPORT_MIME:\n                request = service.files().export_media(\n                    fileId=file_id, mimeType=EXPORT_MIME[mime_type]\n                )\n                base_name, _ = os.path.splitext(filename)\n                filename = base_name + EXPORT_EXT_MAP.get(EXPORT_MIME[mime_type], \"\")\n            else:\n                request = service.files().get_media(fileId=file_id)\n\n            file_buffer = io.BytesIO()\n            loader = MediaIoBaseDownload(file_buffer, request)\n            done = False\n            while not done:\n                status, done = loader.next_chunk()\n                print(f\"Download {int(status.progress() * 100)}%\")\n            file_buffer.seek(0)\n        return file_buffer, filename\n\n\nasync def main():\n    \"\"\"Just for test\"\"\"\n    gapi = GAPIClientWrapper()\n    files = await gapi.list()\n    print(f\"Fetched {len(files)} files md\")\n    print(files)\n    if not files:\n        raise FileNotFoundError\n\n    file, filename = await gapi.getById(file_id=files[0][\"id\"])\n    print(pandas.read_excel(file))\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def progress_update(self, description):\n        await self.emit(description)\n\n    async def error_update(self, description):\n        await self.emit(description, \"error\", True)\n\n    async def success_update(self, description):\n        await self.emit(description, \"success\", True)\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass Tools:\n    class Valves(BaseModel):\n        FOLDER_ID: str = Field(\n            default=None,\n            description=\"ID of a ROOT folder for the agent\",\n        )\n\n        KEY_JSON_CONTENT: str = Field(\n            default=None, description=\"Content of service account key.json\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    async def list_files(\n        self,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__: dict = {},\n    ) -> str:\n        \"\"\"\n        Fetches the lists available files from Google Drive.\n        :return: A list of file_objects\n        \"\"\"\n        gapi = GAPIClientWrapper(\n            service_key=json.loads(self.valves.KEY_JSON_CONTENT),\n            folder_id=self.valves.FOLDER_ID,\n        )\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.progress_update(\"Fetching filenames from Google Drive\")\n        results = await gapi.list(q=\"mimeType != 'application/vnd.google-apps.folder'\")\n        await emitter.success_update(\n            \"Filenames fetched from Google drive successfully!\"\n        )\n        return results\n\n    async def fetch_content(\n        self,\n        file_id,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__: dict = {},\n    ) -> str:\n        \"\"\"\n        Extracts content of a file by its id and transforms it into readable form.\n        :param file_id: String, the id of a file.\n        :return: File content as a string. If possible, as markdown formatted one.\n        \"\"\"\n\n        gapi = GAPIClientWrapper(\n            service_key=json.loads(self.valves.KEY_JSON_CONTENT),\n            folder_id=self.valves.FOLDER_ID,\n        )\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.progress_update(f\"Downloading file {file_id}\")\n        filebytes, filename = await gapi.getById(file_id)\n        await emitter.progress_update(f\"File {filename} downloaded. Parsing...\")\n\n        if filename.endswith(\".pdf\"):\n            doc = pymupdf.Document(stream=filebytes, filetype=\"pdf\")\n            content = pymupdf4llm.to_markdown(\n                doc, ignore_images=True, ignore_graphics=False\n            )\n            await emitter.success_update(f\"File read successfully as PDF - {filename}\")\n            return content\n        elif filename.endswith(\".xlsx\"):\n            content = pandas.read_excel(filebytes).to_markdown(index=False)\n            await emitter.success_update(f\"File read successfully as XLSX- {filename}\")\n            return content\n        else:\n            await emitter.error_update(f\"File format is not supported - {filename}\")\n            return None\n\n\nclass GAPItest(unittest.IsolatedAsyncioTestCase):\n    async def test_list(self):\n        service_key = \"<ENTER key.json content>\"\n        folder_id = \"<ROOT Folder ID>\"\n\n        gapi = GAPIClientWrapper(\n            service_key=json.loads(service_key), folder_id=folder_id\n        )\n        results = await gapi.list(q=\"mimeType != 'application/vnd.google-apps.folder'\")\n        print(results)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n","specs":[{"name":"fetch_content","description":"Extracts content of a file by its id and transforms it into readable form.","parameters":{"properties":{"file_id":{"description":"String, the id of a file."}},"required":["file_id"],"type":"object"}},{"name":"list_files","description":"Fetches the lists available files from Google Drive.","parameters":{"properties":{},"type":"object"}}],"meta":{"description":"A simple Google Drive integration that allows LLMs access files stored at google drive dynamically.","manifest":{"title":"Simple GoogleDrive","author":"Narsonos","description":"A simple Google Drive integration that allows LLMs access files stored at google drive dynamically.","version":"0.0.1","license":"None","requirements":"google-api-python-client, google-auth, google-auth-oauthlib, pandas, pydantic, PyMuPDF, pymupdf4llm, openpyxl, tabulate"}},"access_control":{"read":{"group_ids":[],"user_ids":[]},"write":{"group_ids":[],"user_ids":[]}},"updated_at":1757291966,"created_at":1757288121}